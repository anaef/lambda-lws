#!/usr/bin/env bash
set -euo pipefail

# region
export AWS_REGION="eu-central-1"

# names
REPO="lambda-lws"                        # ECR repo to hold this image family
FUNC_NAME="lambda-lws-examples-default"  # Lambda function name
IMAGE="lambda-lws-examples-default"      # local image to push
IMAGE_TAG="$(date -u +%Y%m%d-%H%M%S)"

ACCOUNT_ID="$(aws sts get-caller-identity --query Account --output text)"
ECR_REGISTRY="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
ECR_URI="${ECR_REGISTRY}/${REPO}:${IMAGE_TAG}"

# ensure ECR repo exists
aws ecr describe-repositories --repository-names "${REPO}" --region "${AWS_REGION}" >/dev/null 2>&1 \
	|| aws ecr create-repository --repository-name "${REPO}" --image-scanning-configuration scanOnPush=true --region "${AWS_REGION}" >/dev/null

# login to ECR
aws ecr get-login-password --region "${AWS_REGION}" \
	| docker login --username AWS --password-stdin "${ECR_REGISTRY}"

# build the exact compose target and push to ECR
docker compose build ${IMAGE}
docker tag lambda-lws/${IMAGE}:latest "${ECR_URI}"
docker push "${ECR_URI}"

# reuse/create execution role
ROLE_ARN="$(aws iam get-role --role-name lambda-basic-execution --query Role.Arn --output text 2>/dev/null || true)"
if [ -z "${ROLE_ARN}" ]; then
	cat > trust-policy.json <<'JSON'
{ "Version":"2012-10-17", "Statement":[{ "Effect":"Allow", "Principal":{"Service":"lambda.amazonaws.com"}, "Action":"sts:AssumeRole"}]}
JSON
	aws iam create-role --role-name lambda-basic-execution --assume-role-policy-document file://trust-policy.json >/dev/null
	aws iam attach-role-policy --role-name lambda-basic-execution \
		--policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole >/dev/null
	ROLE_ARN="$(aws iam get-role --role-name lambda-basic-execution --query Role.Arn --output text)"
fi

# create or update the Lambda function
aws lambda create-function \
	--function-name "$FUNC_NAME" \
	--package-type Image \
	--code ImageUri="$ECR_URI" \
	--role "$ROLE_ARN" \
	--timeout 5 \
	--region "$AWS_REGION" >/dev/null 2>&1 || {
	aws lambda update-function-code \
		--function-name "$FUNC_NAME" \
		--image-uri "$ECR_URI" \
		--region "$AWS_REGION" >/dev/null
	aws lambda wait function-updated \
		--function-name "$FUNC_NAME" \
		--region "$AWS_REGION" >/dev/null
	aws lambda update-function-configuration \
		--function-name "$FUNC_NAME" \
		--timeout 5 \
		--region "$AWS_REGION" >/dev/null
}
aws lambda wait function-updated \
	--function-name "$FUNC_NAME" \
	--region "$AWS_REGION" >/dev/null

# obtain the version of the deployed function
VERSION="$(aws lambda publish-version \
	--function-name "$FUNC_NAME" \
	--region "$AWS_REGION" \
	--query Version --output text)"

# create or update two aliases, "buffered" and "stream"
aws lambda create-alias \
	--function-name "$FUNC_NAME" \
	--name "buffered" \
	--function-version "$VERSION" \
	--region "$AWS_REGION" >/dev/null 2>&1 || \
aws lambda update-alias \
	--function-name "$FUNC_NAME" \
	--name "buffered" \
	--function-version "$VERSION" \
	--region "$AWS_REGION" >/dev/null

aws lambda create-alias \
	--function-name "$FUNC_NAME" \
	--name "stream" \
	--function-version "$VERSION" \
	--region "$AWS_REGION" >/dev/null 2>&1 || \
aws lambda update-alias \
	--function-name "$FUNC_NAME" \
	--name "stream" \
	--function-version "$VERSION" \
	--region "$AWS_REGION" >/dev/null

# create or update two function URLs, one for each alias
aws lambda create-function-url-config \
	--function-name "$FUNC_NAME" \
	--qualifier "buffered" \
	--auth-type NONE \
	--region "$AWS_REGION" >/dev/null 2>&1 || \
aws lambda update-function-url-config \
	--function-name "$FUNC_NAME" \
	--qualifier "buffered" \
	--auth-type NONE \
	--region "$AWS_REGION" >/dev/null
URL_BUFFERED="$(aws lambda get-function-url-config \
	--function-name "$FUNC_NAME" \
	--qualifier "buffered" \
	--query FunctionUrl --output text \
	--region "$AWS_REGION")"

aws lambda create-function-url-config \
	--function-name "$FUNC_NAME" \
	--qualifier "stream" \
	--auth-type NONE \
	--invoke-mode RESPONSE_STREAM \
	--region "$AWS_REGION" >/dev/null 2>&1 || \
aws lambda update-function-url-config \
	--function-name "$FUNC_NAME" \
	--qualifier "stream" \
	--auth-type NONE \
	--invoke-mode RESPONSE_STREAM \
	--region "$AWS_REGION" >/dev/null
URL_STREAM="$(aws lambda get-function-url-config \
	--function-name "$FUNC_NAME" \
	--qualifier "stream" \
	--query FunctionUrl --output text \
	--region "$AWS_REGION")"

# allow public invoke of the function URLs
aws lambda add-permission \
	--function-name "$FUNC_NAME" \
	--qualifier "buffered" \
	--action lambda:InvokeFunctionUrl \
	--principal "*" \
	--function-url-auth-type NONE \
	--statement-id "public-url-buffered" \
	--region "$AWS_REGION" >/dev/null 2>&1 || true

aws lambda add-permission \
	--function-name "$FUNC_NAME" \
	--qualifier "stream" \
	--action lambda:InvokeFunctionUrl \
	--principal "*" \
	--function-url-auth-type NONE \
	--statement-id "public-url-stream" \
	--region "$AWS_REGION" >/dev/null 2>&1 || true

echo "Function URL (buffered): ${URL_BUFFERED}"
echo "Function URL (stream):   ${URL_STREAM}"
